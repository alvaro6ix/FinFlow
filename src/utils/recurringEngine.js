import { addDoc, collection, serverTimestamp, doc, updateDoc, getDocs, query, where } from 'firebase/firestore';
import { db } from '../firebase/config';
import { addDays, addWeeks, addMonths, addYears, isValid, isBefore, isSameDay } from 'date-fns';

export const processRecurringExpenses = async (userId) => {
  if (!userId) return;

  try {
    const q = query(
      collection(db, 'expenses'), 
      where('userId', '==', userId),
      where('isRecurring', '==', true),
      where('isActive', '==', true)
    );

    const snapshot = await getDocs(q);
    const today = new Date();
    today.setHours(23, 59, 59, 999);

    if (snapshot.empty) return;

    for (const docSnapshot of snapshot.docs) {
      try {
        const config = { id: docSnapshot.id, ...docSnapshot.data() };
        if (config.isAutoGenerated) continue;

        // ✅ MAPEADO: Lee 'recurrence' (español) o 'frequency' (inglés)
        const freq = config.recurrence || config.frequency; 
        
        let referenceDate = config.nextOccurrence || config.startDate || config.date;
        let nextDate = referenceDate?.toDate ? referenceDate.toDate() : new Date(referenceDate);
        
        if (!isValid(nextDate)) continue;
        
        let currentDate = new Date(nextDate);
        currentDate.setHours(12, 0, 0, 0); // Estabilizar al mediodía

        let endDate = null;
        if (config.endDate) {
            endDate = config.endDate.toDate ? config.endDate.toDate() : new Date(config.endDate);
        }

        let createdCount = 0;
        let shouldDeactivate = false;

        while (currentDate <= today) {
            // Verificar si ya pasamos la fecha fin
            if (endDate && currentDate > endDate) {
                shouldDeactivate = true;
                break;
            }

            // Evitar duplicar el original si el motor corre el mismo día que se creó
            const parentDate = config.date?.toDate ? config.date.toDate() : new Date(config.date);
            if (isSameDay(currentDate, parentDate)) {
                currentDate = advanceDate(currentDate, freq);
                continue;
            }

            // Query de seguridad anti-duplicados
            const startOfDay = new Date(currentDate);
            startOfDay.setHours(0, 0, 0, 0);
            const endOfDay = new Date(currentDate);
            endOfDay.setHours(23, 59, 59, 999);

            const dupQuery = query(
                collection(db, 'expenses'),
                where('userId', '==', userId), 
                where('masterRecurringId', '==', config.id),
                where('date', '>=', startOfDay),
                where('date', '<=', endOfDay)
            );
            
            const dupSnapshot = await getDocs(dupQuery);
            
            if (dupSnapshot.empty) {
                const newExpense = {
                    ...config,
                    date: new Date(currentDate), 
                    createdAt: serverTimestamp(),
                    isAutoGenerated: true,
                    isRecurring: false,
                    masterRecurringId: config.id,
                    isActive: true
                };
                
                delete newExpense.id;
                delete newExpense.nextOccurrence;
                delete newExpense.recurrence;
                delete newExpense.frequency;
                delete newExpense.startDate;
                delete newExpense.endDate;

                await addDoc(collection(db, 'expenses'), newExpense);
                createdCount++;
            }

            currentDate = advanceDate(currentDate, freq);
            
            // Si después de avanzar ya superamos el fin, marcar para desactivar
            if (endDate && currentDate > endDate) {
                shouldDeactivate = true;
                break;
            }
            if (createdCount > 50) break;
        }

        // Actualizar plantilla
        await updateDoc(doc(db, 'expenses', config.id), {
            nextOccurrence: shouldDeactivate ? null : currentDate,
            lastProcessed: serverTimestamp(),
            isActive: !shouldDeactivate
        });

      } catch (err) {
        console.error("Error en item recurrente:", err.message);
      }
    }
  } catch (error) {
    console.error("Error motor recurrencia:", error);
  }
};

// ✅ FUNCIÓN DE AVANCE CON SOPORTE BILINGÜE
const advanceDate = (date, freq) => {
    let d = new Date(date);
    const f = String(freq).toLowerCase();
    
    if (f === 'diaria' || f === 'daily') return addDays(d, 1);
    if (f === 'semanal' || f === 'weekly') return addWeeks(d, 1);
    if (f === 'quincenal' || f === 'biweekly') return addWeeks(d, 2);
    if (f === 'mensual' || f === 'monthly') return addMonths(d, 1);
    if (f === 'anual' || f === 'yearly') return addYears(d, 1);
    
    return addDays(d, 1); // Fallback seguro
};